name: CI/CD Backend Self-Hosted

on:
  push:
    branches: [main, master]

jobs:
  build_and_deploy:
    runs-on: [self-hosted]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set TAG
        id: tag
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | head -c7)
          echo "TAG=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

      - name: Ajustar permissões do workspace
        run: |
          chown -R "$(whoami)":"$(whoami)" .
          # Às vezes o init-db vira root-owned por bind mounts; garanta que isso também seja corrigido
          chown -R "$(whoami)":"$(whoami)" ./init-db || true
          chmod -R u+rwX ./init-db || true

      - name: Render redis.conf
        run: |
          mkdir -p redis
          cat <<EOF > redis/redis.conf
          requirepass ${{ secrets.REDIS_PASSWORD }}
          save 900 1
          save 300 10
          save 60 10000
          maxmemory 512mb
          maxmemory-policy allkeys-lru
          EOF
          echo "redis.conf criado (senha não exibida por segurança)"

      - name: Construir .env para o ambiente
        run: |
          set -euo pipefail
          TAG=${{ steps.tag.outputs.TAG }}
          
          missing=0
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then echo "Erro: faltando secret JWT_SECRET"; missing=1; fi
          if [ -z "${{ secrets.AUTH_POSTGRES_DB }}" ]; then echo "Erro: faltando secret AUTH_POSTGRES_DB"; missing=1; fi
          if [ -z "${{ secrets.AUTH_POSTGRES_USER }}" ]; then echo "Erro: faltando secret AUTH_POSTGRES_USER"; missing=1; fi
          if [ -z "${{ secrets.AUTH_POSTGRES_PASSWORD }}" ]; then echo "Erro: faltando secret AUTH_POSTGRES_PASSWORD"; missing=1; fi
          if [ -z "${{ secrets.USER_POSTGRES_DB }}" ]; then echo "Erro: faltando secret USER_POSTGRES_DB"; missing=1; fi
          if [ -z "${{ secrets.USER_POSTGRES_USER }}" ]; then echo "Erro: faltando secret USER_POSTGRES_USER"; missing=1; fi
          if [ -z "${{ secrets.USER_POSTGRES_PASSWORD }}" ]; then echo "Erro: faltando secret USER_POSTGRES_PASSWORD"; missing=1; fi
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then echo "Erro: faltando secret REDIS_PASSWORD"; missing=1; fi
          if [ -z "${{ secrets.MONGO_ROOT_USER }}" ]; then echo "Erro: faltando secret MONGO_ROOT_USER"; missing=1; fi
          if [ -z "${{ secrets.MONGO_ROOT_PASSWORD }}" ]; then echo "Erro: faltando secret MONGO_ROOT_PASSWORD"; missing=1; fi
          if [ -z "${{ secrets.LOG_DB_NAME }}" ]; then echo "Erro: faltando secret LOG_DB_NAME"; missing=1; fi
          if [ -z "${{ secrets.LOG_DB_USER }}" ]; then echo "Erro: faltando secret LOG_DB_USER"; missing=1; fi
          if [ -z "${{ secrets.LOG_DB_PASSWORD }}" ]; then echo "Erro: faltando secret LOG_DB_PASSWORD"; missing=1; fi
      
          if [ "$missing" -ne 0 ]; then
            echo "Um ou mais secrets obrigatórios estão ausentes. Abortando."
            exit 1
          fi

          cat <<EOF > .env
          ASPNETCORE_ENVIRONMENT=Production
          ASPNETCORE_URLS=http://+:5000

          # JWT
          JwtSettings__Secret=${{ secrets.JWT_SECRET }}
          JwtSettings__Issuer=AuthService
          JwtSettings__Audience=MyApp

          # Auth Postgres
          AUTH_POSTGRES_DB=${{ secrets.AUTH_POSTGRES_DB }}
          AUTH_POSTGRES_USER=${{ secrets.AUTH_POSTGRES_USER }}
          AUTH_POSTGRES_PASSWORD=${{ secrets.AUTH_POSTGRES_PASSWORD }}
          ConnectionStrings__Auth=Host=postgres-auth;Port=5432;Database=${{ secrets.AUTH_POSTGRES_DB }};Username=${{ secrets.AUTH_POSTGRES_USER }};Password=${{ secrets.AUTH_POSTGRES_PASSWORD }}

          # User Postgres
          USER_POSTGRES_DB=${{ secrets.USER_POSTGRES_DB }}
          USER_POSTGRES_USER=${{ secrets.USER_POSTGRES_USER }}
          USER_POSTGRES_PASSWORD=${{ secrets.USER_POSTGRES_PASSWORD }}
          ConnectionStrings__User=Host=postgres-user;Port=5432;Database=${{ secrets.USER_POSTGRES_DB }};Username=${{ secrets.USER_POSTGRES_USER }};Password=${{ secrets.USER_POSTGRES_PASSWORD }}

          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          REDIS_HOST=redis
          REDIS_PORT=6379

          # Zookeeper/Kafka (reduz warnings)
          KAFKA_BROKER_ID=1
          KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
          KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092
          KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
          ZOOKEEPER_CLIENT_PORT=2181
          ZOOKEEPER_TICK_TIME=2000

          # Mongo usando root
          MONGO_ROOT_USER=${{ secrets.MONGO_ROOT_USER }}
          MONGO_ROOT_PASSWORD=${{ secrets.MONGO_ROOT_PASSWORD }}
          MONGO_INITDB_ROOT_USERNAME=${{ secrets.MONGO_ROOT_USER }}
          MONGO_INITDB_ROOT_PASSWORD=${{ secrets.MONGO_ROOT_PASSWORD }}
          LOG_DB_NAME=${{ secrets.LOG_DB_NAME }}
          LOG_DB_USER=${{ secrets.LOG_DB_USER }}
          LOG_DB_PASSWORD=${{ secrets.LOG_DB_PASSWORD }}

          MongoDb__ConnectionString=mongodb://${{ secrets.MONGO_ROOT_USER }}:${{ secrets.MONGO_ROOT_PASSWORD }}@mongo:27017/${{ secrets.LOG_DB_NAME }}?authSource=admin&retryWrites=true&w=majority
          MongoDb__DatabaseName=${{ secrets.LOG_DB_NAME }}
          MongoDb__CollectionName=Logs

          # Tags de imagem
          AUTH_TAG=${TAG}
          USER_TAG=${TAG}
          LOG_TAG=${TAG}
          EOF

      - name: Mostrar configuração do Compose (validação)
        run: docker compose config

      - name: Build Docker images
        run: |
          TAG=${{ steps.tag.outputs.TAG }}
          echo "Construindo imagens com tag $TAG"
          docker build -t authservice:${TAG} -f AuthService/Dockerfile .
          docker build -t userservice:${TAG} -f UserService/Dockerfile .
          docker build -t logservice:${TAG} -f LogService/Dockerfile .
          docker build -t apigateway:${TAG} -f ApiGateway/Dockerfile .

      - name: Deploy stack
        run: |
          docker compose down --remove-orphans || true
          docker compose up -d --force-recreate --remove-orphans

      - name: Esperar estabilização curta
        run: sleep 5

      - name: Verificar status dos serviços
        run: docker compose ps

      - name: Coletar logs em caso de falha
        if: failure()
        run: |
          echo "=== docker compose ps ==="
          docker compose ps
          echo "=== Últimos 100 logs de cada serviço ==="
          for svc in authservice userservice logservice apigateway kafka zookeeper mongodb; do
            echo "--- logs de $svc ---"
            docker compose logs --tail=100 "$svc" || true
          done

      - name: Clean up dangling Docker images
        if: always()
        run: |
          echo "Limpando imagens dangling para liberar espaço (sem remover cache útil)..."
          docker image prune -f
