name: CI/CD Backend Self-Hosted

on:
  push:
    branches: [ main ]

jobs:
  build_and_deploy:
    runs-on: [self-hosted]  # ou [self-hosted, backend] se usar label específico
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set TAG
        id: tag
        run: echo "TAG=$(echo ${GITHUB_SHA} | head -c7)" >> "$GITHUB_OUTPUT"

      - name: Build Docker images
        run: |
          docker build -t mujapira/authservice:${{ steps.tag.outputs.TAG }} -f AuthService/Dockerfile .
          docker build -t mujapira/userservice:${{ steps.tag.outputs.TAG }} -f UserService/Dockerfile .
          docker build -t mujapira/logservice:${{ steps.tag.outputs.TAG }} -f LogService/Dockerfile .
          docker build -t mujapira/apigateway:${{ steps.tag.outputs.TAG }} -f ApiGateway/Dockerfile .

      - name: Render .env from secrets
        run: |
          cat <<'EOF' > .env
            ASPNETCORE_ENVIRONMENT=Production
            ASPNETCORE_URLS=http://+:5000
            
            # JWT
            JwtSettings__Secret=${{ secrets.JWT_SECRET }}
            JwtSettings__Issuer=AuthService
            JwtSettings__Audience=MyApp
            
            # Auth Postgres
            AUTH_POSTGRES_DB=AuthServiceDb
            AUTH_POSTGRES_USER=auth_prod_user
            AUTH_POSTGRES_PASSWORD=${{ secrets.AUTH_POSTGRES_PASSWORD }}
            
            # User Postgres
            USER_POSTGRES_DB=UserServiceDb
            USER_POSTGRES_USER=user_prod
            USER_POSTGRES_PASSWORD=${{ secrets.USER_POSTGRES_PASSWORD }}
            
            # Redis
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            REDIS_HOST=redis
            REDIS_PORT=6379
            
            # Zookeeper/Kafka (reduz warnings)
            KAFKA_BROKER_ID=1
            KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
            KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092
            KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
            KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
            ZOOKEEPER_CLIENT_PORT=2181
            ZOOKEEPER_TICK_TIME=2000
            
            # Mongo
            MONGO_ROOT_USER=rootadmin
            MONGO_ROOT_PASSWORD=${{ secrets.MONGO_ROOT_PASSWORD }}
            LOG_DB_NAME=LogServiceDb
            LOG_DB_USER=logservice
            LOG_DB_PASSWORD=${{ secrets.LOG_DB_PASSWORD }}
            MongoDb__ConnectionString=mongodb://logservice:${{ secrets.LOG_DB_PASSWORD }}@mongo:27017/LogServiceDb?authSource=LogServiceDb
            MongoDb__DatabaseName=LogServiceDb
            MongoDb__CollectionName=Logs
          EOF

      - name: Create docker-compose.override.yml with current tag
        run: |
          cat <<'EOF' > docker-compose.override.yml
            services:
              authservice:
                image: mujapira/authservice:${{ steps.tag.outputs.TAG }}
              userservice:
                image: mujapira/userservice:${{ steps.tag.outputs.TAG }}
              logservice:
                image: mujapira/logservice:${{ steps.tag.outputs.TAG }}
              apigateway:
                image: mujapira/apigateway:${{ steps.tag.outputs.TAG }}
          EOF

          echo "=== override file content ==="
          cat docker-compose.override.yml

      - name: Validate composed docker config
        run: |
          docker compose config

      - name: Deploy stack
        run: |
          docker compose pull || true
          docker compose up -d --force-recreate --remove-orphans

      - name: Clean up old Docker images
        run: |
          docker image prune -f

      # opcional: reativar depois para garantir que o gateway subiu
      # - name: Healthcheck gateway
      #   run: |
      #     for i in {1..15}; do
      #       if curl --fail http://localhost:5000/health >/dev/null 2>&1; then
      #         echo "Gateway healthy"
      #         exit 0
      #       fi
      #       echo "waiting for gateway... attempt $i"
      #       sleep 2
      #     done
      #     echo "Healthcheck failed"
      #     docker compose ps
      #     docker compose logs authservice userservice apigateway
      #     exit 1

      # opcional: smoke test básico (requer usuário de teste existente)
      # - name: Smoke test login + protected call
      #   env:
      #     TEST_EMAIL: test@example.com
      #     TEST_PASSWORD: testpass
      #   run: |
      #     set -e
      #     login_resp=$(curl -s -c cookies.txt -X POST http://localhost:5000/api/auth/login \
      #       -H "Content-Type: application/json" \
      #       -d "{\"email\":\"${TEST_EMAIL}\",\"password\":\"${TEST_PASSWORD}\"}")
      #     access=$(echo "$login_resp" | jq -r '.accessToken')
      #     if [ -z "$access" ] || [ "$access" = "null" ]; then
      #       echo "Login failed:" "$login_resp"
      #       exit 1
      #     fi
      #     curl -H "Authorization: Bearer $access" http://localhost:5000/users/me
